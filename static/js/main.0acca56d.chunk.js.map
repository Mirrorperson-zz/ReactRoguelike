{"version":3,"sources":["components/Tile.js","components/Agent.js","Utility.js","WorldGeneration/MapGeneration.js","WorldGeneration/AgentsGeneration.js","components/Map.js","App.js","serviceWorker.js","index.js","logo.svg"],"names":["Tile","props","tile","tileType","react_default","a","createElement","className","Agent","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","position","AgentsData","type","startPosition","id","str","agi","dex","wis","int","Component","PondHasTile","pond","map","pondTile","includes","GetTile","row","column","GetAgentWithId","agents","find","agent","ConsoleLogTest","test","message","console","log","RollRandom","max","min","arguments","length","undefined","Math","floor","random","GetNewState","newState","i","rows","push","j","columns","randomRoll","tileOccuranceLimits","allPonds","FindPonds","ResizePonds","pondsEmpty","newPond","newPonds","tileTypes","water","inPond","pondIndex","newPondArray","checkTileRow","checkTileColumn","newPondTile","AddAdjecentWaterTiles","pondArray","condenseCurrent","condenseLimit","_loop","_expandCount","expandCount","InitializeAgents","newTilesStates","newAgents","toConsumableArray","agentsCounter","player","CreateAgent","forEach","rowi","columnTile","columni","shouldCreateAgent","lodashLang","isEqual","agentToCreate","keys","grass","rock","tree","agentName","filter","UpdateStateWithAgents","playerAgent","playerPosition","agentPosition","Map","agentCounter","tilesStates","tilesAgentsStates","playerOn","ponds","updatePlayerPos","newPlayerPosition","oldPlayerPosition","slice","handleKeyPress","event","key","setState","tileStates","newTilesStateWithAgents","objectSpread","_this2","tabIndex","onKeyDown","index","colIndex","components_Tile","App","components_Map","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.0acca56d.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Tile = props => {\r\n  let tile;\r\n\r\n  switch (props.tileType) {\r\n    case 1:\r\n      tile = <div className=\"tile grass\" />;\r\n      break;\r\n    case 2:\r\n      tile = <div className=\"tile rock\" />;\r\n      break;\r\n    case 3:\r\n      tile = <div className=\"tile tree\" />;\r\n      break;\r\n    case 4:\r\n      tile = <div className=\"tile water\" />;\r\n      break;\r\n    default:\r\n      tile = <div className={props.tileType} />;\r\n  }\r\n\r\n  return tile;\r\n};\r\n\r\nexport default Tile;\r\n","import { Component } from 'react';\r\nimport AgentsData from '../AgentsContent.json';\r\n\r\nclass Agent extends Component {\r\n  state = {};\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    let position = props.position\r\n      ? props.position\r\n      : AgentsData[props.type].startPosition;\r\n\r\n    this.state = {\r\n      id: props.id,\r\n      type: props.type,\r\n      str: AgentsData[props.type].str,\r\n      agi: AgentsData[props.type].agi,\r\n      dex: AgentsData[props.type].dex,\r\n      wis: AgentsData[props.type].wis,\r\n      int: AgentsData[props.type].int,\r\n      position: position\r\n    };\r\n  }\r\n}\r\n\r\nexport default Agent;\r\n","import AgentsData from './AgentsContent.json';\r\n\r\nconst PondHasTile = (pond, tile) => {\r\n  let arrayChecks = pond.map(function(pondTile) {\r\n    // Check if each tile in pond is same as tile\r\n    if (pondTile[0] === tile[0] && pondTile[1] === tile[1]) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  });\r\n\r\n  // if any tile matches return true\r\n  return arrayChecks.includes(true);\r\n};\r\n\r\nconst GetTile = (state, row, column) => {\r\n  return state[row][column];\r\n};\r\n\r\nconst GetAgentWithId = (id, agents) => {\r\n  return agents.find(agent => {\r\n    return agent.state.id === id;\r\n  });\r\n};\r\n\r\nconst GetAgentTypes = () => {\r\n  return Object.keys(AgentsData);\r\n};\r\n\r\nconst ConsoleLogTest = (test, message) => {\r\n  if (test) {\r\n    console.log(message);\r\n  }\r\n};\r\n\r\nconst RollRandom = (max, min = 1) => {\r\n  return Math.floor(Math.random() * max - 1) + min;\r\n};\r\n\r\nexport {\r\n  PondHasTile,\r\n  GetTile,\r\n  GetAgentWithId,\r\n  GetAgentTypes,\r\n  ConsoleLogTest,\r\n  RollRandom\r\n};\r\n","import { PondHasTile, GetTile, ConsoleLogTest, RollRandom } from '../Utility';\r\n\r\nconst GetNewState = (props, state) => {\r\n  let newState = [];\r\n\r\n  for (let i = 0; i < props.rows; i++) {\r\n    newState.push([]);\r\n  }\r\n\r\n  for (let i = 0; i < props.rows; i++) {\r\n    for (let j = 0; j < props.columns; j++) {\r\n      let randomRoll = RollRandom(100);\r\n\r\n      if (\r\n        randomRoll >= state.tileOccuranceLimits[0] &&\r\n        randomRoll < state.tileOccuranceLimits[1]\r\n      ) {\r\n        newState[i].push(1);\r\n      } else if (\r\n        randomRoll >= state.tileOccuranceLimits[1] &&\r\n        randomRoll < state.tileOccuranceLimits[2]\r\n      ) {\r\n        newState[i].push(2);\r\n      } else if (\r\n        randomRoll >= state.tileOccuranceLimits[2] &&\r\n        randomRoll < state.tileOccuranceLimits[3]\r\n      ) {\r\n        newState[i].push(3);\r\n      } else if (\r\n        randomRoll >= state.tileOccuranceLimits[3] &&\r\n        randomRoll < state.tileOccuranceLimits[4]\r\n      ) {\r\n        newState[i].push(4);\r\n      }\r\n    }\r\n  }\r\n\r\n  let allPonds = FindPonds(props, state, newState, newState);\r\n  ResizePonds(state, allPonds, newState);\r\n  ConsoleLogTest(state.test, allPonds);\r\n\r\n  return newState;\r\n};\r\n\r\nconst FindPonds = (props, state, allPonds, newState) => {\r\n  let newPonds = [];\r\n  let pondsEmpty;\r\n  let newPond;\r\n\r\n  for (let i = 0; i < props.rows; i++) {\r\n    for (let j = 0; j < props.columns; j++) {\r\n      if (allPonds[i][j] === state.tileTypes.water) {\r\n        pondsEmpty = !newPonds.length > 0;\r\n\r\n        // Check if any registered ponds exist\r\n        if (!pondsEmpty) {\r\n          // Check if tile is alread in a registered pond\r\n          let inPond = [];\r\n          for (let pondIndex = 0; pondIndex < newPonds.length; pondIndex++) {\r\n            inPond.push(PondHasTile(newPonds[pondIndex], [i, j]));\r\n          }\r\n\r\n          // If tile not in any existing ponds newPond is true\r\n          newPond = !inPond.includes(true);\r\n        }\r\n\r\n        // If no ponds exist or tile is of new pond\r\n        if (pondsEmpty || newPond) {\r\n          // Add new pond, first tile\r\n          let newPondArray = [[i, j]];\r\n          let checkTileRow;\r\n          let checkTileColumn;\r\n\r\n          // Check each adjecent tile is water, pushing new tiles into newPond\r\n          for (\r\n            let newPondTile = 0;\r\n            newPondTile < newPondArray.length;\r\n            newPondTile++\r\n          ) {\r\n            checkTileRow = newPondArray[newPondTile][0];\r\n            checkTileColumn = newPondArray[newPondTile][1];\r\n\r\n            //  Limit Tiles Check\r\n            if (newPondTile < 10) {\r\n              AddAdjecentWaterTiles(\r\n                state,\r\n                newState,\r\n                checkTileRow,\r\n                checkTileColumn,\r\n                newPondArray\r\n              );\r\n            } else {\r\n              ConsoleLogTest(state.test, 'Error - newPondTile >= 10');\r\n            }\r\n          }\r\n\r\n          newPonds.push(newPondArray);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return newPonds;\r\n};\r\n\r\nconst AddAdjecentWaterTiles = (state, newState, row, column, pondArray) => {\r\n  // tile above unless at edge\r\n  if (\r\n    row !== 0 &&\r\n    GetTile(newState, row - 1, column) === state.tileTypes.water\r\n  ) {\r\n    // Check it's not a tile already added\r\n    if (!PondHasTile(pondArray, [row - 1, column])) {\r\n      pondArray.push([row - 1, column]);\r\n    }\r\n  }\r\n\r\n  // tile below unless at edge\r\n  if (\r\n    row !== state.rows - 1 &&\r\n    GetTile(newState, row + 1, column) === state.tileTypes.water\r\n  ) {\r\n    // Check it's not a tile already added\r\n    if (!PondHasTile(pondArray, [row + 1, column])) {\r\n      pondArray.push([row + 1, column]);\r\n    }\r\n  }\r\n\r\n  // tile left unless at edge\r\n  if (\r\n    column !== 0 &&\r\n    GetTile(newState, row, column - 1) === state.tileTypes.water\r\n  ) {\r\n    // Check it's not a tile already added\r\n    if (!PondHasTile(pondArray, [row, column - 1])) {\r\n      pondArray.push([row, column - 1]);\r\n    }\r\n  }\r\n\r\n  // tile right unless at edge\r\n  if (\r\n    column !== state.columns - 1 &&\r\n    GetTile(newState, row, column + 1) === state.tileTypes.water\r\n  ) {\r\n    // Check it's not a tile already added\r\n    if (!PondHasTile(pondArray, [row, column + 1])) {\r\n      pondArray.push([row, column + 1]);\r\n    }\r\n  }\r\n};\r\n\r\nconst ResizePonds = (state, allPonds, newState) => {\r\n  let condenseCurrent = 0;\r\n  let condenseLimit = state.condenseLimit;\r\n  let water = state.tileTypes.water;\r\n  let rows = state.rows;\r\n\r\n  return allPonds.map(function(pond) {\r\n    condenseCurrent = Math.floor(Math.random() * condenseLimit - 1) + 1;\r\n\r\n    // if only one tile in pond then resize with condenseCurrent\r\n    if (pond.length < 3) {\r\n      for (let expandCount = 0; expandCount < condenseCurrent; expandCount++) {\r\n        pond.map(function(pondTile) {\r\n          if (\r\n            pondTile[0] !== 0 &&\r\n            newState[pondTile[0] - 1][pondTile[1]] !== water &&\r\n            expandCount < condenseCurrent\r\n          ) {\r\n            newState[pondTile[0] - 1][pondTile[1]] = water;\r\n            expandCount++;\r\n          }\r\n\r\n          if (\r\n            pondTile[0] !== rows - 1 &&\r\n            newState[pondTile[0] + 1][pondTile[1]] !== water &&\r\n            expandCount < condenseCurrent\r\n          ) {\r\n            newState[pondTile[0] + 1][pondTile[1]] = water;\r\n            expandCount++;\r\n          }\r\n\r\n          if (\r\n            pondTile[1] !== 0 &&\r\n            newState[pondTile[0]][pondTile[1] - 1] !== water &&\r\n            expandCount < condenseCurrent\r\n          ) {\r\n            newState[pondTile[0]][pondTile[1] - 1] = water;\r\n            expandCount++;\r\n          }\r\n\r\n          if (\r\n            pondTile[1] !== rows - 1 &&\r\n            newState[pondTile[0]][pondTile[1] + 1] !== water &&\r\n            expandCount < condenseCurrent\r\n          ) {\r\n            newState[pondTile[0]][pondTile[1] + 1] = water;\r\n            expandCount++;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nexport { ResizePonds, FindPonds, GetNewState };\r\n","import Agent from '../components/Agent';\r\nimport {\r\n  GetAgentWithId,\r\n  GetAgentTypes,\r\n  ConsoleLogTest,\r\n  RollRandom\r\n} from '../Utility';\r\nimport AgentsData from '../AgentsContent.json';\r\nimport lodashLang from 'lodash/lang';\r\n\r\nconst InitializeAgents = (state, newTilesStates) => {\r\n  let newAgents = [...state.agents];\r\n  let agentsCounter = 0;\r\n\r\n  let player = CreateAgent('a' + agentsCounter, 'player');\r\n  newAgents.push(player);\r\n  agentsCounter++;\r\n\r\n  newTilesStates.forEach((row, rowi) => {\r\n    row.forEach((columnTile, columni) => {\r\n      // Roll about 10% for if there is an agent in tile\r\n      let shouldCreateAgent = RollRandom(100) < 10 ? true : false;\r\n\r\n      if (lodashLang.isEqual(player.state.position, [rowi, columni])) {\r\n        shouldCreateAgent = false;\r\n      }\r\n\r\n      if (shouldCreateAgent) {\r\n        // Roll another for what agent it should be, chances depending on tile type\r\n        let agentToCreate = RollRandom(Object.keys(AgentsData).length - 1, 1);\r\n\r\n        // Use Switch to vary changes depending on tile type - WIP\r\n        switch (columnTile) {\r\n          case state.tileTypes.grass:\r\n            break;\r\n          case state.tileTypes.rock:\r\n            break;\r\n          case state.tileTypes.tree:\r\n            break;\r\n          case state.tileTypes.water:\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n\r\n        // Get key/name of agentToCreate from AgentsData after removing player\r\n        let agentName = Object.keys(AgentsData).filter(\r\n          agent => agent !== 'player'\r\n        )[agentToCreate];\r\n\r\n        newAgents.push(\r\n          CreateAgent('a' + agentsCounter, agentName, [rowi, columni])\r\n        );\r\n        agentsCounter++;\r\n      }\r\n    });\r\n  });\r\n\r\n  ConsoleLogTest(state.test, GetAgentTypes());\r\n\r\n  return newAgents;\r\n};\r\n\r\nconst CreateAgent = (id, type, position = null) => {\r\n  return new Agent({ id, type, position });\r\n};\r\n\r\nconst UpdateStateWithAgents = (newTilesStates, newAgents) => {\r\n  // set player - x and y are reversed, because array within array\r\n  let playerAgent = GetAgentWithId('a0', newAgents);\r\n  let playerPosition = playerAgent.state.position;\r\n  newTilesStates[playerPosition[1]][playerPosition[0]] = playerAgent.state.id;\r\n\r\n  newAgents.forEach(agent => {\r\n    let agentPosition = agent.state.position;\r\n    newTilesStates[agentPosition[1]][agentPosition[0]] = agent.state.id;\r\n  });\r\n\r\n  return newTilesStates;\r\n};\r\n\r\nexport { CreateAgent, UpdateStateWithAgents, InitializeAgents };\r\n","import React, { Component } from 'react';\r\nimport Tile from './Tile';\r\nimport Agent from './Agent';\r\nimport { GetNewState } from '../WorldGeneration/MapGeneration';\r\nimport {\r\n  UpdateStateWithAgents,\r\n  InitializeAgents\r\n} from '../WorldGeneration/AgentsGeneration';\r\nimport { GetAgentWithId, ConsoleLogTest } from '../Utility';\r\n\r\nclass Map extends Component {\r\n  state = {\r\n    test: this.props.test,\r\n    agentCounter: 0,\r\n    columns: this.props.columns,\r\n    rows: this.props.rows,\r\n    tilesStates: [[]],\r\n    tilesAgentsStates: [[]],\r\n    tileTypes: {\r\n      grass: 0,\r\n      rock: 1,\r\n      tree: 2,\r\n      water: 3\r\n    },\r\n    tileOccuranceLimits: [0, 60, 75, 85, 100],\r\n    playerOn: 1,\r\n    ponds: [],\r\n    condenseLimit: 3,\r\n    agents: []\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    let newTilesStates = GetNewState(props, this.state);\r\n    let newAgents = InitializeAgents(this.state, newTilesStates);\r\n    let newTilesStateWithAgents = UpdateStateWithAgents(\r\n      newTilesStates,\r\n      newAgents\r\n    );\r\n\r\n    this.state = {\r\n      ...this.state,\r\n      agents: newAgents,\r\n      tilesStates: newTilesStates,\r\n      tilesAgentsStates: newTilesStateWithAgents,\r\n      agentCounter: this.state.agentCounter + newAgents.length\r\n    };\r\n  }\r\n\r\n  updatePlayerPos = (\r\n    newPlayerPosition,\r\n    oldPlayerPosition\r\n    // Flip when use as colums in rows means need [y,x]\r\n  ) => {\r\n    let newState = this.state.tilesStates.slice(0);\r\n    // Add old tile player is on\r\n    newState[oldPlayerPosition[1]][oldPlayerPosition[0]] = this.state.playerOn;\r\n\r\n    // Add player to new tile - a0 is player agent's id\r\n    newState[newPlayerPosition[1]][newPlayerPosition[0]] = 'a0';\r\n\r\n    return newState;\r\n  };\r\n\r\n  // movement controls\r\n  handleKeyPress = event => {\r\n    // check keys\r\n    ConsoleLogTest(this.state.test, 'key pressed ' + event.key);\r\n\r\n    let newAgents = [...this.state.agents];\r\n    let oldPlayerPosition = [...GetAgentWithId('a0', newAgents).state.position];\r\n    let newPlayerPosition;\r\n\r\n    // TileStates is an array in an array; first array index is rows and send array index is columns.\r\n    // Fist index controls vertical movement, second index controls horizontal movement\r\n    switch (event.key) {\r\n      case 'ArrowLeft':\r\n        newPlayerPosition = [oldPlayerPosition[0] - 1, oldPlayerPosition[1]];\r\n        if (newPlayerPosition[0] <= 0) return;\r\n        break;\r\n\r\n      case 'ArrowRight':\r\n        newPlayerPosition = [oldPlayerPosition[0] + 1, oldPlayerPosition[1]];\r\n        if (newPlayerPosition[0] >= this.props.columns - 1) return;\r\n        break;\r\n\r\n      case 'ArrowUp':\r\n        newPlayerPosition = [oldPlayerPosition[0], oldPlayerPosition[1] - 1];\r\n        if (newPlayerPosition[1] <= 0) return;\r\n        break;\r\n\r\n      case 'ArrowDown':\r\n        newPlayerPosition = [oldPlayerPosition[0], oldPlayerPosition[1] + 1];\r\n        if (newPlayerPosition[1] >= this.props.rows - 1) return;\r\n        break;\r\n\r\n      default:\r\n        newPlayerPosition = oldPlayerPosition;\r\n    }\r\n\r\n    GetAgentWithId('a0', newAgents).state.position = newPlayerPosition;\r\n\r\n    if (newPlayerPosition !== oldPlayerPosition) {\r\n      this.setState(state => ({\r\n        agents: newAgents,\r\n        playerOn: this.state.tilesStates[newPlayerPosition[1]][\r\n          newPlayerPosition[0]\r\n        ], // Order matters store tile player moving to\r\n        tileStates: this.updatePlayerPos(newPlayerPosition, oldPlayerPosition) // then move player\r\n      }));\r\n    }\r\n  };\r\n\r\n  render() {\r\n    ConsoleLogTest(this.state.test, this.state.tilesAgentsStates);\r\n    return (\r\n      <div tabIndex=\"0\" onKeyDown={this.handleKeyPress}>\r\n        {this.state.tilesAgentsStates.map((rows, index) => (\r\n          <div key={index}>\r\n            {this.state.tilesAgentsStates[index].map((tileType, colIndex) => (\r\n              <Tile\r\n                tileType={\r\n                  tileType[0] === 'a' // is agent\r\n                    ? 'tile ' +\r\n                      GetAgentWithId(tileType, this.state.agents).state.type\r\n                    : tileType\r\n                }\r\n                key={index * this.state.rows + colIndex}\r\n                test={this.state.test}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Map;\r\n","import React, { Component } from 'react';\r\nimport logo from './logo.svg';\r\nimport Map from './components/Map';\r\nimport './App.css';\r\nimport './Game.css';\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <Map rows={10} columns={10} test={true} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}